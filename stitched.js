
(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), module = cache[path], fn;
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn(module.exports, function(name) {
            return require(name, dirname(path));
          }, module);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module \'' + name + '\' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle)
        modules[key] = bundle[key];
    };
  }
  return this.require.define;
}).call(this)({"BloomFilter": function(exports, require, module) {// Generated by CoffeeScript 1.6.3
var ArrayBitSet, BitSet, ConciseBitSet, HashGenerator, SHA1, ScalableBloomFilter, SlicedBloomFilter, StrictSlicedBloomFilter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SHA1 = require('crypto/sha1').hex_hmac_sha1;

/*
# The sliced bloom filter optimizes the filter by partitioning the bit array into a segment
# that is reserved for each hash function. Note that once the the @count > @capacity the % failure
# is now > @errorRate!
#
# This implementation is derived from 'Scalable Bloom Filters':
#
# http://en.wikipedia.org/wiki/Bloom_filter#CITEREFAlmeidaBaqueroPreguicaHutchison2007
*/


SlicedBloomFilter = (function() {
  SlicedBloomFilter.count = 0;

  SlicedBloomFilter.slices = null;

  SlicedBloomFilter.fromJSON = function(json) {
    var s, slices, _i, _j, _len, _len1, _ref, _ref1;
    slices = [];
    if (json.slicesType === 'ArrayBitSet') {
      _ref = json.slices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        slices.push(ArrayBitSet.fromJSON(s));
      }
    } else {
      _ref1 = json.slices;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        s = _ref1[_j];
        slices.push(ConciseBitSet.fromJSON(s));
      }
    }
    return new SlicedBloomFilter(json.capacity, json.errorRate, slices, json.count, json.hashStartChar);
  };

  function SlicedBloomFilter(capacity, errorRate, slices, count, hashStartChar) {
    var cnt, i, _i, _ref;
    this.capacity = capacity != null ? capacity : 100;
    this.errorRate = errorRate != null ? errorRate : .001;
    this.slices = slices != null ? slices : null;
    this.count = count != null ? count : 0;
    this.hashStartChar = hashStartChar != null ? hashStartChar : 'h';
    this.bitsPerInt = 32;
    this.totalSize = Math.floor(this.capacity * Math.abs(Math.log(this.errorRate)) / Math.pow(Math.log(2), 2));
    if (this.totalSize < 0) {
      throw "total size is bigger than an int! " + this.totalSize;
    }
    this.numSlices = Math.ceil(Math.log(1 / this.errorRate) / Math.log(2));
    cnt = 0;
    this.sliceLen = Math.ceil(this.totalSize / this.numSlices);
    this.hashgenerator = new HashGenerator(this.hashStartChar, this.sliceLen);
    if (!this.slices) {
      this.slicesType = 'ArrayBitSet';
      this.slices = [];
      for (i = _i = 0, _ref = this.numSlices - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.slices.push(new ArrayBitSet(this.sliceLen, this.bitsPerInt));
      }
    } else {
      if (!(this.slices[0] instanceof ArrayBitSet)) {
        this.slicesType = 'ConciseBitSet';
      }
    }
    if (this.slices.length !== this.numSlices) {
      throw "numSlices doesn't match slices: " + this.slices.length + " != " + this.numSlices;
    }
    if (this.slices[0].length * this.bitsPerInt < this.sliceLen) {
      throw "sliceLen doesn't match slice lengths: " + this.sliceLen + " !< " + (this.slices[0].length * this.bitsPerInt);
    }
  }

  SlicedBloomFilter.prototype.add = function(k) {
    var i, _i, _ref;
    this.hashgenerator.reset(k);
    for (i = _i = 0, _ref = this.numSlices - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.slices[i].add(this.hashgenerator.getIndex());
    }
    this.count++;
    return this;
  };

  SlicedBloomFilter.prototype.has = function(k) {
    var i, index, _i, _ref;
    this.hashgenerator.reset(k);
    for (i = _i = 0, _ref = this.numSlices - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      index = this.hashgenerator.getIndex();
      if (!this.slices[i].has(index)) {
        return false;
      }
    }
    return true;
  };

  SlicedBloomFilter.prototype.readOnlyInstance = function() {
    var ROslices, s, sbf, _i, _len, _ref;
    ROslices = [];
    _ref = this.slices;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      s = _ref[_i];
      ROslices.push(s.toConciseBitSet());
    }
    sbf = new SlicedBloomFilter(this.capacity, this.errorRate, ROslices, this.count, this.hashStartChar);
    return sbf;
  };

  return SlicedBloomFilter;

})();

/*
# Strict filter: fail if you attempt to stuff more into it than its configured to handle.
*/


StrictSlicedBloomFilter = (function(_super) {
  __extends(StrictSlicedBloomFilter, _super);

  StrictSlicedBloomFilter.fromJSON = function(json) {
    var sbl;
    sbl = SlicedBloomFilter.fromJSON(json);
    return new StrictSlicedBloomFilter(sbl.capacity, sbl.errorRate, sbl.slices, sbl.count, sbl.hashStartChar);
  };

  function StrictSlicedBloomFilter(capacity, errorRate, slices, count, hashStartChar) {
    this.capacity = capacity != null ? capacity : 100;
    this.errorRate = errorRate != null ? errorRate : .001;
    this.slices = slices != null ? slices : null;
    this.count = count != null ? count : 0;
    this.hashStartChar = hashStartChar != null ? hashStartChar : 'h';
    StrictSlicedBloomFilter.__super__.constructor.call(this, this.capacity, this.errorRate, this.slices, this.count, this.hashStartChar);
  }

  StrictSlicedBloomFilter.prototype.add = function(k) {
    if (this.count >= this.capacity) {
      throw "count should be <= capacity, no more room: " + this.count + " <= " + this.capacity;
    }
    return StrictSlicedBloomFilter.__super__.add.call(this, k);
  };

  return StrictSlicedBloomFilter;

})(SlicedBloomFilter);

/*
# A hash function. It is intended to be used to:
#
# 1: set the key/length of indexes
# 2: fetch several random indexes.
#
# This class automatically handles the hash generation - minimizing the
# total number of hashes generated.
*/


HashGenerator = (function() {
  function HashGenerator(hashStartChar, len) {
    this.hashStartChar = hashStartChar;
    this.len = len;
    this.hexCharsNeeded = Math.ceil(Math.log(this.len) / Math.log(16));
  }

  /*
  # Anchor the generator on to a specific key. Reset any hash data.
  */


  HashGenerator.prototype.reset = function(key) {
    this.key = key;
    this.hashCnt = 0;
    return this.hash = "";
  };

  HashGenerator.prototype.getIndex = function() {
    var c;
    if (this.hash === "" || this.hashIdx > this.hash.length - this.hexCharsNeeded) {
      this.hash = SHA1("" + this.hashStartChar + "-" + this.hashCnt + "-" + this.key, this.key) + this.hash.slice(this.hashIdx, this.hash.length);
      this.hashCnt++;
      this.hashIdx = 0;
    }
    if (this.len > Math.pow(2, 31)) {
      console.log("WARNING: watch out, I think this is too big. Key: '" + this.key + "' Len: " + this.len);
    }
    c = parseInt(this.hash.slice(this.hashIdx, this.hashIdx + this.hexCharsNeeded), 16);
    this.hashIdx += this.hexCharsNeeded;
    return c;
  };

  return HashGenerator;

})();

/*
# Base bit set class (abstract). These bitset implementations are used by the
# bloom filters as underlying storage.
*/


BitSet = (function() {
  function BitSet() {}

  BitSet.prototype.add = function(b) {};

  BitSet.prototype.has = function(b) {
    return false;
  };

  BitSet.prototype.bitStringAsWord = function(str) {
    var b, bit, offset, _i, _len;
    b = 0;
    offset = 31;
    for (_i = 0, _len = str.length; _i < _len; _i++) {
      bit = str[_i];
      if (bit !== ' ') {
        b = b | (parseInt(bit) << offset--);
      }
    }
    return b;
  };

  BitSet.prototype.wordAsBitString = function(w) {
    var i, str, _i;
    str = "";
    for (i = _i = 31; _i >= 0; i = --_i) {
      if ((i + 1) % 4 === 0 && i !== 31) {
        str += " ";
      }
      if (this.bitOfWordSet(w, i)) {
        str += "1";
      } else {
        str += "0";
      }
    }
    return str;
  };

  BitSet.prototype.bitOfWordSet = function(w, i) {
    return (w & (1 << i)) !== 0;
  };

  BitSet.prototype.bitsOfWordSet = function(w) {
    var cnt, i, _i;
    cnt = 0;
    for (i = _i = 0; _i <= 31; i = ++_i) {
      if (this.bitOfWordSet(w, i)) {
        cnt++;
      }
    }
    return cnt;
  };

  BitSet.prototype.wordMatches = function(w, p) {
    var allMatch, i, _i;
    allMatch = true;
    for (i = _i = 0; _i <= 31; i = ++_i) {
      allMatch = this.bitOfWordSet(w, i) === this.bitOfWordSet(p, i);
      if (!allMatch) {
        return false;
      }
    }
    return true;
  };

  return BitSet;

})();

/*
# Straight up array based bit set (well, we use the bits of the ints in the array).
*/


ArrayBitSet = (function(_super) {
  __extends(ArrayBitSet, _super);

  ArrayBitSet.fromJSON = function(json) {
    return new ArrayBitSet(json.size, json.bitsPerInt, json.data, json.max);
  };

  function ArrayBitSet(size, bitsPerInt, data, max) {
    var cnt;
    this.size = size;
    this.bitsPerInt = bitsPerInt != null ? bitsPerInt : 32;
    this.data = data != null ? data : [];
    this.max = max;
    cnt = 0;
    while (cnt < this.size) {
      this.data.push(0);
      cnt += this.bitsPerInt;
    }
  }

  ArrayBitSet.prototype.computeIndexes = function(bit) {
    return [Math.floor(bit / this.bitsPerInt), Math.ceil(bit % this.bitsPerInt)];
  };

  ArrayBitSet.prototype.add = function(bit) {
    var mask, parts;
    if (bit >= this.size * this.bitsPerInt) {
      throw "Array is setup for " + (this.size * this.bitsPerInt) + " bits, but bit " + bit + " was attempted.";
    }
    parts = this.computeIndexes(bit);
    mask = 1 << parts[1] - 1;
    this.data[parts[0]] = this.data[parts[0]] | mask;
    if (bit > this.max) {
      return this.max = bit;
    }
  };

  ArrayBitSet.prototype.has = function(bit) {
    var mask, parts;
    if (bit >= this.size * this.bitsPerInt) {
      return false;
    }
    parts = this.computeIndexes(bit);
    mask = 1 << parts[1] - 1;
    return (this.data[parts[0]] & mask) !== 0;
  };

  ArrayBitSet.prototype.toConciseBitSet = function() {
    var cbs, cnt, i, max, _i, _ref;
    cbs = new ConciseBitSet();
    cnt = 0;
    max = 0;
    for (i = _i = 0, _ref = this.size * this.bitsPerInt; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (this.has(i)) {
        cnt++;
        max = i;
        cbs.add(i);
      }
    }
    return cbs;
  };

  ArrayBitSet.prototype.printObject = function() {
    var i, w, _i, _len, _ref, _results;
    console.log("size = " + this.size);
    _ref = this.data;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      w = _ref[i];
      _results.push(console.log("word " + i + " : " + (this.wordAsBitString(w))));
    }
    return _results;
  };

  return ArrayBitSet;

})(BitSet);

/*
# CONCISE bit set.
# unfortunately you can't use the CONCISE bit for a writeable bloom filter so
# we are just using it for the read only version - for its space saving features.
#
# This bitmap is really only useful if the bloom filter is mostly full, or mostly empty. In that
# middle state, there aren't sparse areas of 1s or 0s for it to compress.
#
# If the # of items in the bloom filter is near the capacity of the filter, the standard array
# is almost always better (uses less space)
*/


ConciseBitSet = (function(_super) {
  __extends(ConciseBitSet, _super);

  ConciseBitSet.fromJSON = function(json) {
    return new ConciseBitSet(json.words, json.top, json.max, json.count);
  };

  function ConciseBitSet(words, top, max, count) {
    this.words = words != null ? words : [];
    this.top = top != null ? top : 0;
    this.max = max != null ? max : 0;
    this.count = count != null ? count : 0;
  }

  ConciseBitSet.prototype.add = function(i) {
    var b, f, zeroBlocks;
    if (this.words.length === 0) {
      f = Math.floor(i / 31.0);
      switch (f) {
        case 0:
          this.top = 0;
          break;
        case 1:
          this.top = 1;
          this.setWord(0, 0x80000000);
          break;
        default:
          this.top = 1;
          this.setWord(0, f - 1);
      }
      this.setWord(this.top, 0x80000000 | (1 << (i % 31)));
    } else {
      b = i - this.max + (this.max % 31);
      if (b >= 31) {
        zeroBlocks = Math.floor(b / 31.0) - 1;
        b = b % 31;
        if (zeroBlocks > 0) {
          this.appendSequence(zeroBlocks, 0);
        }
        this.appendLiteral(0x80000000 | (1 << b));
      } else {
        this.setWord(this.top, this.words[this.top] | (1 << b));
        if (this.wordMatches(this.words[this.top], 0xffffffff)) {
          this.top = this.top - 1;
          if (this.top < 0) {
            this.words = [];
          }
          if (this.top < 0) {
            this.top = 0;
          }
          this.appendLiteral(0xffffffff);
        }
      }
    }
    this.max = i;
    return this.count++;
  };

  ConciseBitSet.prototype.appendLiteral = function(w) {
    if (this.top === 0 && this.wordMatches(w, 0x80000000) && this.wordMatches(this.words[0], 0x01ffffff)) {
      return;
    }
    if (this.words.length === 0) {
      this.top = 0;
      return this.setWord(this.top, w);
    } else if (this.wordMatches(w, 0x80000000)) {
      if (this.wordMatches(this.words[this.top], 0x80000000)) {
        return this.setWord(this.top, 1);
      } else if ((this.words[this.top] & 0xc0000000) === 0) {
        return this.setWord(this.top, this.words[this.top] + 1);
      } else if (this.containsOneBit(0x7fffffff & this.words[this.top])) {
        return this.setWord(this.top, 1 | ((1 + this.trailingZeros(this.words[this.top])) << 25));
      } else {
        this.top++;
        return this.setWord(this.top, w);
      }
    } else if (this.wordMatches(w, 0xffffffff)) {
      if (this.wordMatches(this.words[this.top], 0xffffffff)) {
        return this.setWord(this.top, 0x40000000 | 1);
      } else if (this.wordMatches(this.words[this.top] & 0xc0000000, 0x40000000)) {
        return this.setWord(this.top, this.words[this.top] + 1);
      } else if (this.containsOneBit(~this.words[this.top])) {
        return this.setWord(this.top, 0x40000000 | 1 | ((1 + this.trailingZeros(~this.words[this.top])) << 25));
      } else {
        this.top++;
        return this.setWord(this.top, w);
      }
    } else {
      this.top++;
      return this.setWord(this.top, w);
    }
  };

  ConciseBitSet.prototype.appendSequence = function(l, t) {
    t = t & 0x40000000;
    if (l === 1) {
      if (t === 0) {
        return this.appendLiteral(0x80000000);
      } else {
        return this.appendLiteral(0xffffffff);
      }
    } else if (this.words.length === 0) {
      this.top = 0;
      return this.setWord(this.top, t | (l - 1));
    } else if (this.isLiteral(this.words[this.top])) {
      if (t === 0 && this.wordMatches(this.words[this.top], 0x80000000)) {
        return this.setWord(this.top, l);
      } else if (this.wordMatches(t, 0x40000000) || this.wordMatches(this.words[this.top], 0xffffffff)) {
        return this.setWord(this.top, 0x40000000 | l);
      } else if (t === 0 && this.containsOneBit(0x7fffffff & this.words[this.top])) {
        return this.setWord(this.top, l | ((1 + this.trailingZeros(this.words[this.top])) << 25));
      } else if (this.wordMatches(t, 0x40000000) && this.containsOneBit(~this.words[this.top])) {
        return this.setWord(this.top, 0x40000000 | l | ((1 + this.trailingZeros(~this.words[this.top])) << 25));
      } else {
        this.top++;
        return this.setWord(this.top, t | (l - 1));
      }
    } else if (this.wordMatches(this.words[this.top] & 0xc0000000, t)) {
      return this.setWord(this.top, this.words[this.top] + l);
    } else {
      this.top++;
      return this.setWord(this.top, t | (l - 1));
    }
  };

  ConciseBitSet.prototype.setWord = function(i, w) {
    if (i > this.words.length) {
      throw "index i (" + i + ") should be no more than 1 more than @words length (currently " + this.words.length;
    }
    if (this.words.length < i - 1) {
      return this.words.push(w);
    } else {
      return this.words[i] = w;
    }
  };

  ConciseBitSet.prototype.printObject = function() {
    var i, w, _i, _len, _ref, _results;
    console.log("top = " + this.top);
    console.log("max = " + this.max);
    console.log("count = " + this.count);
    _ref = this.words;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      w = _ref[i];
      if (i <= this.top) {
        _results.push(console.log("word " + i + " : " + (this.wordAsBitString(w))));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  ConciseBitSet.prototype.isLiteral = function(w) {
    return (w & 0x80000000) !== 0;
  };

  ConciseBitSet.prototype.is01Fill = function(w) {
    return (w & 0x80000000) === 0 && (w & 0x40000000) !== 0;
  };

  ConciseBitSet.prototype.is00Fill = function(w) {
    return (w & 0x80000000) === 0 && (w & 0x40000000) === 0;
  };

  ConciseBitSet.prototype.bitCount = function(arr) {
    var cnt, w, _i, _len;
    if (arr == null) {
      arr = this.words;
    }
    cnt = 0;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      w = arr[_i];
      if (this.isLiteral(w)) {
        cnt += this.bitsOfWordSet(w) - 1;
      } else if (this.is01Fill(w)) {
        cnt += 31 + 31 * this.bitsOfWordSet(w & 0x7ffffff);
        cnt -= this.bitsOfWordSet((w >> 25) & 0x1f);
      } else if (this.is00Fill(w)) {
        cnt += this.bitsOfWordSet((w >> 25) & 0x1f);
      } else {
        throw "Should start with 1, or 00 or 01 !?";
      }
    }
    return cnt;
  };

  ConciseBitSet.prototype.has = function(n) {
    var bit, block, w, _i, _len, _ref;
    if (n > this.max || this.words.length === 0 || n < 0) {
      return false;
    }
    block = Math.floor(n / 31.0);
    bit = n % 31;
    _ref = this.words;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      w = _ref[_i];
      if (this.isLiteral(w)) {
        if (block === 0) {
          return (w & (1 << bit)) !== 0;
        }
        block--;
        /*
        if n - height <= 31
          return @bitOfWordSet(w,n-height)
        height += 31
        */

      } else if (this.is01Fill(w)) {
        if (block === 0 && this.wordMatches(0x0000001f & (w >> 25) - 1, bit)) {
          return false;
        }
        block -= (w & 0x01FFFFFF) + 1;
        if (block < 0) {
          return true;
        }
      } else if (this.is00Fill(w)) {
        if (block === 0 && this.wordMatches((w >> 25) - 1, bit)) {
          return true;
        }
        block -= (w & 0x01FFFFFF) + 1;
        if (block < 0) {
          return false;
        }
      }
    }
    return false;
  };

  ConciseBitSet.prototype.containsOneBit = function(w) {
    return (w & (w - 1)) === 0;
  };

  ConciseBitSet.prototype.trailingZeros = function(v) {
    var c, foundOne;
    c = 0;
    if (v !== 0) {
      foundOne = false;
      v = v ^ 0x80000000;
      while (!foundOne) {
        if ((v & 1) === 0) {
          c++;
        } else {
          foundOne = true;
        }
        v >>= 1;
      }
    } else {
      c = 32;
    }
    return c;
  };

  return ConciseBitSet;

})(BitSet);

/*
# A bloom filter that grows automatically.
# Consists of several SlicedBloomFilter's to ensure that the
# filter maintains its % error.
#
# http://en.wikipedia.org/wiki/Bloom_filter#CITEREFAlmeidaBaqueroPreguicaHutchison2007
*/


ScalableBloomFilter = (function() {
  ScalableBloomFilter.fromJSON = function(json) {
    var f, filters, _i, _len, _ref;
    filters = [];
    _ref = json.filters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      filters.push(StrictSlicedBloomFilter.fromJSON(f));
    }
    return new ScalableBloomFilter(json.startcapacity, json.targetErrorRate, filters, json.stages, json.r, json.count);
  };

  function ScalableBloomFilter(startcapacity, targetErrorRate, filters, stages, r, count) {
    this.startcapacity = startcapacity != null ? startcapacity : 100;
    this.targetErrorRate = targetErrorRate != null ? targetErrorRate : .001;
    this.filters = filters != null ? filters : null;
    this.stages = stages != null ? stages : 4;
    this.r = r != null ? r : 0.85;
    this.count = count != null ? count : 0;
    this.P_0 = this.targetErrorRate * (1 - this.r);
    if (!this.filters) {
      this.filters = [new StrictSlicedBloomFilter(this.startcapacity, this.P_0, null, 0, 'h0')];
    }
  }

  ScalableBloomFilter.prototype.add = function(k) {
    var f, _i, _len, _ref;
    this.count = 0;
    _ref = this.filters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      this.count += f.count;
      if (f.count < f.capacity) {
        f.add(k);
        this.count++;
        return this;
      }
    }
    this.count++;
    this.filters.push(new StrictSlicedBloomFilter(this.startcapacity * Math.pow(this.stages, this.filters.length), this.P_0 * Math.pow(this.r, this.filters.length), null, 0, "h" + this.filters.length));
    this.filters[this.filters.length - 1].add(k);
    return this;
  };

  ScalableBloomFilter.prototype.has = function(k) {
    var f, _i, _len, _ref;
    _ref = this.filters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      if (f.has(k)) {
        return true;
      }
    }
    return false;
  };

  ScalableBloomFilter.prototype.readOnlyInstance = function() {
    var ROfilters, f, _i, _len, _ref;
    ROfilters = [];
    _ref = this.filters;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      ROfilters.push(f.readOnlyInstance());
    }
    return new ScalableBloomFilter(this.startcapacity, this.targetErrorRate, ROfilters, this.stages, this.r, this.count);
  };

  return ScalableBloomFilter;

})();

module.exports = {
  BloomFilter: SlicedBloomFilter,
  StrictBloomFilter: StrictSlicedBloomFilter,
  ScalableBloomFilter: ScalableBloomFilter,
  ConciseBitSet: ConciseBitSet,
  ArrayBitSet: ArrayBitSet
};
}, "crypto/md5": function(exports, require, module) {/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
(typeof define !== "function" ? function($){ $(require, exports, module); } : define)(function(require, exports, module, undefined) {

exports.hex_md5 = hex_md5;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

});
}, "crypto/sha1": function(exports, require, module) {/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */
(typeof define !== "function" ? function($){ $(require, exports, module); } : define)(function(require, exports, module, undefined) {

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}

});
}, "crypto/test/test-crypto": function(exports, require, module) {"use strict";

if (module == require.main)
  require("test").run(exports);
}});
